<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
         AsRef vs Borrow vs Deref Busted
        
    </title><meta content="AsRef vs Borrow vs Deref Busted" property=og:title><meta content="Welcome to my personal site where I share my thoughts, projects, and experiences." property=og:description><meta content="Welcome to my personal site where I share my thoughts, projects, and experiences." name=description><link href=/icon/favicon.png rel=icon type=image/png><link href=https://artech-git.github.io/fonts.css rel=stylesheet><script src=https://artech-git.github.io/js/codeblock.js></script><script src=https://artech-git.github.io/js/toc.js></script><script src=https://artech-git.github.io/js/note.js></script><script>MathJax={tex:{inlineMath:[[`\$`,`\$`],[`\\\\(`,`\\\\)`]]}}</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link href=https://artech-git.github.io/atom.xml rel=alternate title=artech type=application/atom+xml><link href=https://artech-git.github.io/theme/light.css rel=stylesheet><link href=https://artech-git.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://artech-git.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme())</script><link href=https://artech-git.github.io/main.css media=screen rel=stylesheet><body><div class=content><header><div class=main><a href=https://artech-git.github.io/>artech</a><div class=socials><a class=social href=https://github.com/artech-git/ rel=me> <img alt=github src=https://artech-git.github.io/social_icons/github.svg> </a><a class=social href=https://www.linkedin.com/in/prabhat25/ rel=me> <img alt=linked src=https://artech-git.github.io/social_icons/linkedin.svg> </a></div></div><nav><a href=https://artech-git.github.io/posts style=margin-left:.5em>/posts</a><a href=https://artech-git.github.io/projects style=margin-left:.5em>/projects</a><a href=https://artech-git.github.io/courses style=margin-left:.5em>/courses</a><a href=https://artech-git.github.io/books style=margin-left:.5em>/books</a><a href=https://artech-git.github.io/resume style=margin-left:.5em>/resume</a><a href=https://artech-git.github.io/talks style=margin-left:.5em>/talks</a><a href=https://artech-git.github.io/certs style=margin-left:.5em>/certs</a><a href=https://artech-git.github.io/about style=margin-left:.5em>/about</a> |<a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://artech-git.github.io/feather/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://artech-git.github.io/feather/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><main><article><div class=title><div class=page-header>AsRef vs Borrow vs Deref Busted<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2024-12-06</time><span class=tags-label> :: Tags:</span><span class=tags> <a class=post-tag href=https://artech-git.github.io/tags/coding/>coding</a> </span> :: <a rel="noopener noreferrer" href=https://github.com/artech-git/artech-git.github.io/tree/main/contentposts/asref_borrow_deref.md target=_blank> Source Code</a></div></div><div class=toc-container><h1 class=toc-title>Table of Contents</h1><ul class=toc-list><li><a href=https://artech-git.github.io/posts/asref-borrow-deref/#similarity>Similarity</a><li><a href=https://artech-git.github.io/posts/asref-borrow-deref/#asref-vs-borrow-vs-deref-in-rust>AsRef vs Borrow vs Deref in Rust</a> <ul><li><a href=https://artech-git.github.io/posts/asref-borrow-deref/#asref-asmut-trait>AsRef & AsMut trait</a></li><ul><li><a href=https://artech-git.github.io/posts/asref-borrow-deref/#common-use-cases>Common Use Cases</a><li><a href=https://artech-git.github.io/posts/asref-borrow-deref/#points-to-note-while-using-asref-asmut>Points to note while using AsRef & AsMut</a></ul><li><a href=https://artech-git.github.io/posts/asref-borrow-deref/#borrow-borrowmut>Borrow & BorrowMut</a></li><ul><li><a href=https://artech-git.github.io/posts/asref-borrow-deref/#common-use-cases-1>Common Use Cases</a><li><a href=https://artech-git.github.io/posts/asref-borrow-deref/#deref-coercion>Deref Coercion</a></ul><li><a href=https://artech-git.github.io/posts/asref-borrow-deref/#comparison-table>Comparison Table</a><li><a href=https://artech-git.github.io/posts/asref-borrow-deref/#common-gotchas>Common Gotchas</a><li><a href=https://artech-git.github.io/posts/asref-borrow-deref/#summary>Summary</a></ul></ul></div><section class=body><p>It is common to encounter a situation where you may require to return a different type either as a immutable or mutable reference which can be a field of a struct or a completely new type composed out of a given type for some operation<p>You may also have come across such type expression <code>impl AsRef&LTstr></code> or <code>where T: Borrow<[u8]></code> or something like <code>impl Deref&LTTarget = [u8]></code> these kinds of expression are common to come across which can be tricky sometimes to understand and draw a distinction among it.<p>It's quite common to come across these traits in standard library <code>AsRef&LTT></code> / <code>AsMut&LTT></code>, <code>Borrow</code> / <code>BorrowMut</code> and <code>Deref</code> / <code>DerefMut</code>.<p>Unless you have good background with rust, The first thought which may come to mind after looking at these traits is they are naturally made for producing a subtype or newtype from a given type when called! well this is unfortunately not true. If this was true then standard library won't be having these many traits!<h1 id=similarity><a aria-label="Anchor link for: similarity" class=zola-anchor href=#similarity>Similarity</a></h1><p>But before we start to look over there <strong>characteristics</strong> and <strong>differences</strong>, Let's cover there similarities first, keep this in mind following similarities are not strongly same but similar or close to being similar depending upon situation, and in some simple situations could be used interchangibely, let's check them out !<ul><li>Simplification of borrow: All the above traits are used to simplify access to data. They allow for different ways of referring to an object, typically without taking ownership of real one. <ul><li>with AsRef & AsMut</ul> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>impl </span><span style=color:#55b4d4;font-style:italic>AsRef</span><span>&LTCar> </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>FourWheeler </span><span>{
</span><span>    </span><span style=color:#ed9366>...
</span><span>} 
</span></code></pre> <ul><li>with Borrow trait</ul> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>impl </span><span>Borrow&LTCar> </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>FourWheeler </span><span>{
</span><span>    </span><span style=color:#ed9366>...
</span><span>}
</span></code></pre> <ul><li>with Deref and DerefMut</ul> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>impl </span><span>Deref </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>FourWheeler </span><span>{
</span><span>    </span><span style=color:#fa6e32>type </span><span style=color:#399ee6>Target </span><span style=color:#ed9366>=</span><span> Car</span><span style=color:#61676ccc>; 
</span><span>    </span><span style=color:#ed9366>...
</span><span>}
</span></code></pre></ul><ul><li>Conversion support to Non-sized types: Each trait definition allows conversion to non-sized types, as shown in the definition of each trait bellow, you will notice this. <ul><li>With <code>AsRef</code> & <code>AsMut</code></ul> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>AsRef</span><span>&LTT>
</span><span> where
</span><span>     T: ?Sized, </span><span style=color:#abb0b6;font-style:italic>// Non-sized type
</span><span> {
</span><span>     </span><span style=color:#abb0b6;font-style:italic>// Required method
</span><span>     </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>as_ref</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span>T</span><span style=color:#61676ccc>;
</span><span> }
</span></code></pre> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>AsMut</span><span>&LTT>
</span><span>where
</span><span>    T: ?Sized, </span><span style=color:#abb0b6;font-style:italic>// Non-sized type
</span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Required method
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>as_mut</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> T</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre> <ul><li>With <code>Borrow</code> & <code>BorrowMut</code> trait</ul> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>Borrow</span><span>&LTBorrowed>
</span><span> where
</span><span>     Borrowed: ?Sized, </span><span style=color:#abb0b6;font-style:italic>// Non-sized type
</span><span> {
</span><span>     </span><span style=color:#abb0b6;font-style:italic>// Required method
</span><span>     </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>borrow</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span>Borrowed</span><span style=color:#61676ccc>;
</span><span> }
</span></code></pre> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>BorrowMut</span><span>&LTBorrowed>: Borrow&LTBorrowed>
</span><span>where
</span><span>    Borrowed: ?Sized, </span><span style=color:#abb0b6;font-style:italic>// Non-sized type
</span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Required method
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>borrow_mut</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> Borrowed</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre> <ul><li>With <code>Deref</code> & <code>DerefMut</code></ul> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span> </span><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>Deref </span><span>{
</span><span>     </span><span style=color:#fa6e32>type </span><span style=color:#399ee6>Target</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>?</span><span style=color:#55b4d4;font-style:italic>Sized</span><span style=color:#61676ccc>; </span><span style=color:#abb0b6;font-style:italic>// Non-sized type
</span><span>
</span><span>     </span><span style=color:#abb0b6;font-style:italic>// Required method
</span><span>     </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>deref</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span>Target</span><span style=color:#61676ccc>;
</span><span> }
</span></code></pre> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>DerefMut</span><span>: Deref {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Required method
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>deref_mut</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut Self</span><span style=color:#ed9366>::</span><span>Target</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><li>Used in Generic Programming: All three traits are highly useful in generic programming, where you want to write functions or structs that can operate on references to data rather than the data itself. <ul><li>With <code>AsRef</code> & <code>AsMut</code> you may have the impelmentation for any given type such following</ul> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>//case 1 
</span><span style=color:#fa6e32>impl </span><span style=color:#55b4d4;font-style:italic>AsRef</span><span><</span><span style=color:#fa6e32>str</span><span>> </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>T </span><span>{ 
</span><span>    </span><span style=color:#ed9366>...
</span><span>} 
</span><span style=color:#abb0b6;font-style:italic>//case 2
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>compute</span><span>&LTT>(</span><span style=color:#ff8f40>s</span><span style=color:#61676ccc>:</span><span> impl </span><span style=color:#55b4d4;font-style:italic>AsRef</span><span>&LTT>) </span><span style=color:#fa6e32>where</span><span> T</span><span style=color:#61676ccc>:</span><span> ToString ..
</span><span>
</span><span style=color:#abb0b6;font-style:italic>//case 3 
</span><span>struct Car&LTI> {
</span><span>    tires</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Box</span><span>&LTdyn </span><span style=color:#55b4d4;font-style:italic>AsRef</span><span>&LTI>>
</span><span>    </span><span style=color:#ed9366>...
</span><span>}
</span></code></pre> <ul><li><p>with <code>Borrow</code> & <code>BorrowMut</code> traits you can still acheive same exact thing as above</p><li><p>with <code>Deref</code> & <code>DerefMut</code> things get bit special due to associated type in it's signature definition</p></ul> <pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>//case 1
</span><span style=color:#fa6e32>impl</span><span>&LTY> Deref </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>SomeType 
</span><span> </span><span style=color:#fa6e32>where</span><span> Y</span><span style=color:#61676ccc>: </span><span>std</span><span style=color:#ed9366>::</span><span>fmt</span><span style=color:#ed9366>::</span><span>Debug {
</span><span>    </span><span style=color:#fa6e32>type </span><span style=color:#399ee6>Target </span><span style=color:#ed9366>=</span><span> Y</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>deref</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span>Target {
</span><span>        </span><span style=color:#ed9366>...
</span><span>    } 
</span><span>}
</span><span style=color:#abb0b6;font-style:italic>//case 2
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>accept_deref</span><span>&LTU>(</span><span style=color:#ff8f40>s</span><span style=color:#61676ccc>:</span><span> impl Deref&LTTarget=U>) </span><span style=color:#fa6e32>where</span><span> U</span><span style=color:#61676ccc>:</span><span> ToString ...
</span><span>
</span><span style=color:#abb0b6;font-style:italic>//case 3
</span><span>struct Truck&LTI> {
</span><span>    tires</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Box</span><span>&LTdyn Deref&LTTarget = I>>
</span><span>    </span><span style=color:#ed9366>...
</span><span>}
</span></code></pre></ul><h1 id=asref-vs-borrow-vs-deref-in-rust><a aria-label="Anchor link for: asref-vs-borrow-vs-deref-in-rust" class=zola-anchor href=#asref-vs-borrow-vs-deref-in-rust>AsRef vs Borrow vs Deref in Rust</a></h1><h2 id=asref-asmut-trait><a aria-label="Anchor link for: asref-asmut-trait" class=zola-anchor href=#asref-asmut-trait>AsRef & AsMut trait</a></h2><p><code>AsRef</code> is a trait for performing cheap reference-to-reference conversions. This includes read and write borrows! It's most commonly used for functions that can accept multiple types of concrete references. It can also be used to borrow non-sized types!<p>Let's check out a simple example first. In the example below, we are trying to borrow a type as a <code>str</code>, but we are allowed to pass each type as a reference as illustrated below.<h3 id=common-use-cases><a aria-label="Anchor link for: common-use-cases" class=zola-anchor href=#common-use-cases>Common Use Cases</a></h3><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>process_string</span><span>&LTT</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>AsRef</span><span><</span><span style=color:#fa6e32>str</span><span>>>(</span><span style=color:#ff8f40>s</span><span style=color:#61676ccc>:</span><span> T) {
</span><span>    </span><span style=color:#fa6e32>let</span><span> s_ref</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>str </span><span style=color:#ed9366>=</span><span> s</span><span style=color:#ed9366>.</span><span style=color:#f07171>as_ref</span><span>()</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Process the string slice
</span><span>}
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// Can be called with different types
</span><span style=color:#fa6e32>let</span><span> string </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>String</span><span style=color:#ed9366>::</span><span>from(</span><span style=color:#86b300>"hello"</span><span>)</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>let</span><span> str_literal </span><span style=color:#ed9366>= </span><span style=color:#86b300>"world"</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#f07171>process_string</span><span>(</span><span style=color:#ed9366>&</span><span>string)</span><span style=color:#61676ccc>;  </span><span style=color:#abb0b6;font-style:italic>// works
</span><span style=color:#f07171>process_string</span><span>(str_literal)</span><span style=color:#61676ccc>;  </span><span style=color:#abb0b6;font-style:italic>// also works
</span></code></pre><p>In the above example, we have seen how we can pass around all those types that implement <code>AsRef</code>. These types are now qualified to be passed as owned types, and later, using the <code>as_ref()</code> method, we can call that type to be represented as the intended type as a read-only reference.<p>Since there exist implementations for <code>&str</code> and <code>String</code> types as shown below:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>impl </span><span style=color:#55b4d4;font-style:italic>AsRef</span><span><</span><span style=color:#fa6e32>str</span><span>> </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>String </span><span>{
</span><span>    </span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>inline</span><span>]
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>as_ref</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>str </span><span>{
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self
</span><span>    }
</span><span>}
</span></code></pre><p>and for <code>str</code> type<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>impl </span><span style=color:#55b4d4;font-style:italic>AsRef</span><span><</span><span style=color:#fa6e32>str</span><span>> </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>str </span><span>{
</span><span>    </span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>inline</span><span>(always)]
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>as_ref</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>str </span><span>{
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self
</span><span>    }
</span><span>}
</span></code></pre><p>Interestingly, if you observe carefully here, you will find that <code>AsRef</code> doesn't write the following type signature for the generic position <code>AsRef<&str></code> instead, it writes <code>AsRef&LTstr></code>. If you are wondering why this is, check out these two posts respectively: <a href=https://doc.rust-lang.org/nomicon/exotic-sizes.html>Rust nomicon reference</a> and <a href=https://smallcultfollowing.com/babysteps/blog/2024/04/23/dynsized-unsized/>Niko Matsakis</a>, to understand the difference. Now, if you look at the trait function <code>fn as_ref(&self) -> &str</code>, it returns a borrowed version. Frankly, the explanation behind how <code>str</code> is borrowed into <code>&str</code> deserves its own post, but to give a short answer: inside the method, <code>self</code> is already of type <code>&str</code> because we're implementing a method that takes <code>&self</code>, so we can just return it directly since it matches the return type.<p>Now let's move our attention towards <code>AsMut</code>, which lets us borrow a type mutably. If you visit the standard library, you will find there exist implementations for <code>AsMut</code> for <code>str</code> and <code>String</code> types. These implementations are as follows:<p>For the string type:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>impl </span><span style=color:#55b4d4;font-style:italic>AsMut</span><span><</span><span style=color:#fa6e32>str</span><span>> </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>String </span><span>{
</span><span>    </span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>inline</span><span>]
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>as_mut</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut str </span><span>{
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self
</span><span>    }
</span><span>}
</span></code></pre><p>for str type<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>impl </span><span style=color:#55b4d4;font-style:italic>AsMut</span><span><</span><span style=color:#fa6e32>str</span><span>> </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>str </span><span>{
</span><span>    </span><span style=color:#61676ccc>#</span><span>[</span><span style=color:#f29718>inline</span><span>(always)]
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>as_mut</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut str </span><span>{
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self
</span><span>    }
</span><span>}
</span></code></pre><p>Interestingly, this time we borrow both of our types as mutable references <code>&mut str</code>.<p>By now, I am hoping this has brought some clarity regarding how the <code>AsRef</code> and <code>AsMut</code> traits can be used. The real power of these traits lies in their flexibility regarding how they can be used.<p>Pay attention to how <code>AsRef</code> and <code>AsMut</code> are totally independent of each other, meaning they don't have any associated type dependency or super trait requirement, unlike what we previously saw for the <code>Borrow</code>, <code>BorrowMut</code>, <code>Deref</code>, and <code>DerefMut</code> traits. Hence, we are given complete flexibility in how one concrete type can be cheaply converted into another type. Let's understand this explanation through an example.<p>Let's think of a situation where you wish to convert a book type <code>Book</code> into some primitive representation such as <code>&str</code> as an immutable borrow only, and also as <code>Vec&LTString></code> as a mutable reference.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>struct </span><span style=color:#399ee6>Book </span><span>{
</span><span>    title</span><span style=color:#61676ccc>:</span><span> String,
</span><span>    pages</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Vec</span><span><</span><span style=color:#55b4d4;font-style:italic>String</span><span>>,
</span><span>}
</span></code></pre><p>writing a simple <code>AsRef</code> conversion is possible, given if it <strong>makes sense to use that type temporarly</strong><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>impl </span><span style=color:#55b4d4;font-style:italic>AsRef</span><span><</span><span style=color:#fa6e32>str</span><span>> </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>Book </span><span>{
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>as_ref</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>str </span><span>{
</span><span>        </span><span style=color:#ed9366>&</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>title  </span><span style=color:#abb0b6;font-style:italic>// We can reference the title as a &str
</span><span>    }
</span><span>}
</span></code></pre><p>in a simple manner it is possible to write a <code>AsMut&LTVec&LTString>></code> conversion as well<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Implement AsMut&LTVec&LTString>> for Book to modify pages
</span><span style=color:#fa6e32>impl </span><span style=color:#55b4d4;font-style:italic>AsMut</span><span><</span><span style=color:#55b4d4;font-style:italic>Vec</span><span><</span><span style=color:#55b4d4;font-style:italic>String</span><span>>> </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>Book </span><span>{
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>as_mut</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#55b4d4;font-style:italic>Vec</span><span><</span><span style=color:#55b4d4;font-style:italic>String</span><span>> {
</span><span>        </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>pages  </span><span style=color:#abb0b6;font-style:italic>// We can get a mutable reference to pages
</span><span>    }
</span><span>}
</span></code></pre><p>following from previous, it is possible to write a <code>AsMut<[str]></code> conversion as well<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>impl </span><span style=color:#55b4d4;font-style:italic>AsMut</span><span><[</span><span style=color:#55b4d4;font-style:italic>String</span><span>]> </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>Book </span><span>{
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>as_mut</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span>[</span><span style=color:#55b4d4;font-style:italic>String</span><span>] {
</span><span>        </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span>pages  </span><span style=color:#abb0b6;font-style:italic>// We can get a mutable reference to pages
</span><span>    }
</span><span>}
</span></code></pre><h3 id=points-to-note-while-using-asref-asmut><a aria-label="Anchor link for: points-to-note-while-using-asref-asmut" class=zola-anchor href=#points-to-note-while-using-asref-asmut>Points to note while using AsRef & AsMut</a></h3><ul><li>Usage of these traits is best suited when you have to derive a type that is mostly a field of a struct, and the conversion doesn't involve any expensive computation.<li>These traits give you flexibility in usage, meaning you may have a single <code>AsRef</code> for some type, whereas you may have several <code>AsMut</code> for distinct types, and they don't depend on each other in any way!<li>It's better to avoid writing these traits for <code>Non-Sized</code> types such as <code>&dyn ..</code> or <code>&mut dyn..</code>.</ul><h2 id=borrow-borrowmut><a aria-label="Anchor link for: borrow-borrowmut" class=zola-anchor href=#borrow-borrowmut>Borrow & BorrowMut</a></h2><p>The <code>Borrow</code> trait is similar to the <code>AsRef</code> trait in that it supports borrowing of type A into type B, but the catch is that it lets you borrow rather than convert something. Hence, the point of comparison shall be between <strong>how to distinguish between borrowing and conversion</strong>.<p><strong>Conversion of any type to another type is straightforward since it doesn't enforce us to carry any further semantic information, while borrowing shall satisfy such norms.</strong><p>From the above information, <code>Borrow</code> is similar to <code>AsRef</code> but with an additional contract: the borrowed form must <strong>hash, compare, and order the same as the owned form</strong>.<p>Let's check out its definition first.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>Borrow</span><span>&LTBorrowed: ?Sized> {
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>borrow</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span>Borrowed</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>In above definition we have declared out borrow to be a generic just like <code>AsRef</code> which can be Non-sized type and borrows immutably, but we would also need to borrow mutably, let's checkout the definition for <code>BorrowMut</code> trait in detail<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>BorrowMut</span><span>&LTBorrowed>: Borrow&LTBorrowed>
</span><span>where
</span><span>    Borrowed: ?Sized,
</span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Required method
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>borrow_mut</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> Borrowed</span><span style=color:#61676ccc>;
</span><span>}
</span><span>For the `BorrowMut` definition</span><span style=color:#61676ccc>, </span><span style=color:#ed9366>as</span><span> we can clearly observe</span><span style=color:#61676ccc>,</span><span> it depends on the `Borrow&LTBorrowed>` implementation</span><span style=color:#61676ccc>,</span><span> which is generic over `Borrowed`</span><span style=color:#ed9366>.</span><span> Therefore</span><span style=color:#61676ccc>,</span><span> types that are going to implement `BorrowMut&LTBorrowed>` must first implement the immutable version</span><span style=color:#61676ccc>,</span><span> i</span><span style=color:#ed9366>.</span><span>e</span><span style=color:#ed9366>.</span><span style=color:#61676ccc>,</span><span> `Borrow&LTBorrowed>`</span><span style=color:#ed9366>.</span><span> This enforces a </span><span style=color:#fa6e32>type </span><span style=color:#399ee6>to</span><span> be borrowable </span><span style=color:#ed9366>in</span><span> both forms</span><span style=color:#61676ccc>,</span><span> i</span><span style=color:#ed9366>.</span><span>e</span><span style=color:#ed9366>.</span><span style=color:#61676ccc>,</span><span> `</span><span style=color:#ed9366>&</span><span>T` and `</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut</span><span> T`</span><span style=color:#61676ccc>,</span><span> unlike the `</span><span style=color:#55b4d4;font-style:italic>AsRef</span><span>` and `</span><span style=color:#55b4d4;font-style:italic>AsMut</span><span>` traits</span><span style=color:#61676ccc>,</span><span> which can be totally independent of each other and have no correlation between them</span><span style=color:#ed9366>.
</span><span>
</span><span>Let</span><span style=color:#fa6e32>'s</span><span> check out the `std</span><span style=color:#ed9366>::</span><span>collections</span><span style=color:#ed9366>::</span><span>HashMap` definition regarding the `Borrow` </span><span style=color:#fa6e32>trait</span><span style=color:#ed9366>.
</span><span>
</span><span style=color:#ed9366>###</span><span> Use Cases
</span><span>```rust
</span><span style=color:#abb0b6;font-style:italic>// struct definition
</span><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>HashMap</span><span>&LTK, V, S = RandomState>
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// method get definition 
</span><span>pub fn get&LTQ: ?Sized>(</span><span style=color:#ed9366>&</span><span>self, k: </span><span style=color:#ed9366>&</span><span>Q) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span>V>
</span><span style=color:#fa6e32>where
</span><span>    K</span><span style=color:#61676ccc>: </span><span>Borrow&LTQ></span><span style=color:#61676ccc>, </span><span style=color:#abb0b6;font-style:italic>// Observe how Borrow trait is used 
</span><span>    Q</span><span style=color:#61676ccc>:</span><span> Hash </span><span style=color:#ed9366>+ </span><span style=color:#55b4d4;font-style:italic>Eq</span><span style=color:#61676ccc>,
</span><span>{
</span><span>    </span><span style=color:#ed9366>...
</span><span>}
</span><span>The </span><span style=color:#fa6e32>type </span><span style=color:#399ee6>definition</span><span> of `HashMap&LTK, V>` is generic over three parameters</span><span style=color:#61676ccc>,</span><span> but we will only consider `K` and `V`</span><span style=color:#61676ccc>,</span><span> which are </span><span style=color:#fa6e32>for</span><span> key and value respectively</span><span style=color:#61676ccc>, </span><span style=color:#fa6e32>for</span><span> simplicity</span><span style=color:#ed9366>.</span><span> Now</span><span style=color:#61676ccc>, </span><span style=color:#fa6e32>if</span><span> we look at the method `get`</span><span style=color:#61676ccc>,</span><span> it declares another generic `Q` which can be borrowed from `k`</span><span style=color:#61676ccc>,</span><span> and `Q` must implement `Hash </span><span style=color:#ed9366>+ </span><span style=color:#55b4d4;font-style:italic>Eq</span><span>` traits </span><span style=color:#ed9366>as</span><span> bounds</span><span style=color:#61676ccc>,</span><span> since it requires that keys can be distinguishable</span><span style=color:#ed9366>.
</span><span>
</span><span>This requirement is present </span><span style=color:#fa6e32>for</span><span> multiple methods of collection types within the standard library</span><span style=color:#ed9366>.
</span><span>
</span><span style=color:#ed9366>**</span><span>Note</span><span style=color:#61676ccc>:</span><span> `Borrow` </span><span style=color:#ed9366>&</span><span> `BorrowMut` themselves </span><span style=color:#f51818>do</span><span> not enforce the semantic requirements through their definitions</span><span style=color:#ed9366>.</span><span> It is up to the defining method or </span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>to</span><span> declare how semantics are going to be enforced via them.**
</span><span>
</span><span>Borrow traits can also be useful for types where we want to retrieve an internal type rather than a composed one, such as for `Vec&LTT>`, which can be borrowed as a mutable slice `&mut [T]` and modified directly rather than converting it first.
</span><span>
</span><span>### Points to note
</span><span>1. Stricter semantic requirements, though not required by default.
</span><span>2. Essentially used for collection types such as HashMap and BtreeMap.
</span><span>3. Useful when you need to work on a subtype of some composed type which might require modification.
</span><span>4. There may exist several definitions for a given type to be borrowed in different types.
</span><span>
</span><span>## Deref & DerefMut
</span><span>The trait `Deref` is one of my personal favorites and quite a powerful one among all.
</span><span>`Deref` is used for dereferencing operations using the `*` operator and for automatic dereferencing to a defined type.
</span><span>Unlike traits `Borrow` & `AsRef`, `Deref` carries an associated type as part of its definition and can only be applied once.
</span><span>Let's check out its definition.
</span><span>
</span><span>```rust
</span><span>pub trait Deref {
</span><span>    type Target</span><span style=color:#61676ccc>:</span><span> ?Sized;
</span><span>    fn deref(</span><span style=color:#ed9366>&</span><span>self) -> </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span>Target;
</span><span>}
</span></code></pre><p>In the above definition it returns a associated type as immutable reference, now let's take a look for <code>DerefMut</code><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub trait </span><span style=color:#399ee6>DerefMut</span><span>: Deref {
</span><span>    </span><span style=color:#abb0b6;font-style:italic>// Required method
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>deref_mut</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut Self</span><span style=color:#ed9366>::</span><span>Target</span><span style=color:#61676ccc>;
</span><span>}
</span></code></pre><p>As you can clearly see, just like <code>BorrowMut</code>, <code>DerefMut</code> also depends on <code>Deref</code> to be pre-implemented for a type. Interestingly, the return type belongs to the super trait <code>Deref</code>, which can be borrowed mutably. This has two major advantages:<ul><li>The output type for both borrows can't be changed since it is based on the associated type.<li>It prevents the implementation from existing for more than one type.</ul><p>To find out more about how associated types are different from generics, I recommend you read this blog <a href=https://doc.rust-lang.org/book/ch19-03-advanced-traits.html>here</a>.<p>Once a type implements deref traits, it can now automatically call the methods of dereferenced types using the dot <code>.</code> operator.<p>Let's look at a simple example here.<h3 id=common-use-cases-1><a aria-label="Anchor link for: common-use-cases-1" class=zola-anchor href=#common-use-cases-1>Common Use Cases</a></h3><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>use </span><span>std</span><span style=color:#ed9366>::</span><span>ops</span><span style=color:#ed9366>::</span><span>Deref</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>MyBox</span><span>(</span><span style=color:#55b4d4;font-style:italic>Vec</span><span><</span><span style=color:#fa6e32>u8</span><span>>)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>impl </span><span style=color:#399ee6>MyBox </span><span>{
</span><span>    </span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>my_box_len</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#fa6e32>usize </span><span>{
</span><span>        </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0.</span><span style=color:#f07171>len</span><span>()
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#fa6e32>impl </span><span>Deref </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>MyBox </span><span>{
</span><span>    </span><span style=color:#fa6e32>type </span><span style=color:#399ee6>Target </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>Vec</span><span><</span><span style=color:#fa6e32>u8</span><span>></span><span style=color:#61676ccc>;
</span><span>    
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>deref</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span>Target {
</span><span>        </span><span style=color:#ed9366>&</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#fa6e32>let mut</span><span> x </span><span style=color:#ed9366>=</span><span> MyBox(</span><span style=color:#f07171>vec!</span><span>[</span><span style=color:#ff8f40>4</span><span>])</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// valid
</span><span style=color:#fa6e32>let</span><span> len_one </span><span style=color:#ed9366>=</span><span> x</span><span style=color:#ed9366>.</span><span style=color:#f07171>my_box_len</span><span>()</span><span style=color:#61676ccc>; 
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// also valid, we are directly Vec::len() method since it only takes &self
</span><span style=color:#fa6e32>let</span><span> len </span><span style=color:#ed9366>=</span><span> x</span><span style=color:#ed9366>.</span><span style=color:#f07171>len</span><span>() 
</span><span>
</span></code></pre><p>Incase we require some mutable borrows<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>impl </span><span>DerefMut </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>MyBox </span><span>{
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>deref_mut</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut Self</span><span style=color:#ed9366>::</span><span>Target {
</span><span>        </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0
</span><span>    }
</span><span>}
</span></code></pre><p>now we can call any mutable method over <code>Vec&LTu8></code><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>let</span><span> _val </span><span style=color:#ed9366>=</span><span> x</span><span style=color:#ed9366>.</span><span style=color:#f07171>remove</span><span>(</span><span style=color:#ff8f40>0</span><span>)</span><span style=color:#61676ccc>; </span><span style=color:#abb0b6;font-style:italic>// x -> .remove()
</span></code></pre><p>Those types which implement <code>Deref</code> trait are automatically qualified to use <code>*</code> operator for explicit dereferencing,<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>let</span><span> _val </span><span style=color:#ed9366>= </span><span>(</span><span style=color:#ed9366>*</span><span>x)</span><span style=color:#ed9366>.</span><span style=color:#f07171>remove</span><span>(</span><span style=color:#ff8f40>0</span><span>)</span><span style=color:#61676ccc>;  </span><span style=color:#abb0b6;font-style:italic>// x -> Vec&LTu8> -> .remove()
</span><span>Now you might wonder why both expressions are making valid calls to `remove`</span><span style=color:#ed9366>.</span><span> Once a </span><span style=color:#fa6e32>type </span><span style=color:#399ee6>implements</span><span> the `Deref` </span><span style=color:#fa6e32>trait</span><span style=color:#61676ccc>,</span><span> it will attempt to call the respective method through implicit dereferencing </span><span style=color:#ed9366>**</span><span style=color:#fa6e32>if</span><span> required</span><span style=color:#ed9366>**</span><span> and will make multiple attempts </span><span style=color:#fa6e32>if</span><span> the subtype also implements `Deref`</span><span style=color:#ed9366>.
</span><span>
</span><span>Here is a straightforward example</span><span style=color:#61676ccc>:
</span><span>
</span><span>```rust
</span><span style=color:#fa6e32>let</span><span> _val</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut u8</span><span>> </span><span style=color:#ed9366>=</span><span> x</span><span style=color:#ed9366>.</span><span style=color:#f07171>last_mut</span><span>()</span><span style=color:#61676ccc>; </span><span style=color:#abb0b6;font-style:italic>// x -> Vec&LTu8> -> &mut [u8]
</span></code></pre><p>If you visit <code>Vec&LTu8></code>, you will find that it implements <a href=https://doc.rust-lang.org/std/vec/struct.Vec.html#deref-methods-%5BT%5D><code>Deref&LTTarget=[u8]></code></a>, hence all the methods on <code>&mut [u8]</code> are directly accessible to us.<p>This is very useful, but if not used cautiously, it could be the cause of bugs sometimes, since you may call methods on some other type other than the desired type! Luckily, in such cases, only methods that are first observed through implicit dereference are called.<h3 id=deref-coercion><a aria-label="Anchor link for: deref-coercion" class=zola-anchor href=#deref-coercion>Deref Coercion</a></h3><p>One of the most powerful features of <code>Deref</code> is onsite coercion if a type implements deref traits. This could be helpful where we wish to avoid explicit casting/conversions:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>fn </span><span style=color:#f29718>takes_str</span><span>(</span><span style=color:#ff8f40>s</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>str</span><span>) {
</span><span>    </span><span style=color:#f07171>println!</span><span>(</span><span style=color:#86b300>"</span><span style=color:#ff8f40>{}</span><span style=color:#86b300>"</span><span style=color:#61676ccc>,</span><span> s)</span><span style=color:#61676ccc>;
</span><span>}
</span><span>
</span><span style=color:#fa6e32>let</span><span> string </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>String</span><span style=color:#ed9366>::</span><span>from(</span><span style=color:#86b300>"hello"</span><span>)</span><span style=color:#61676ccc>;
</span><span style=color:#f07171>takes_str</span><span>(</span><span style=color:#ed9366>&</span><span>string)</span><span style=color:#61676ccc>;  </span><span style=color:#abb0b6;font-style:italic>// Works because String: Deref&LTTarget=str>
</span><span style=color:#f07171>takes_str</span><span>(</span><span style=color:#86b300>"string2"</span><span>)</span><span style=color:#61676ccc>;  </span><span style=color:#abb0b6;font-style:italic>// also works because it is a concrete type
</span></code></pre><p>But hold on a second, why would we need such an onsite coercion feature if we already have <code>AsRef</code> and <code>Borrow</code> traits to take care of the job? Well, I'm glad you asked!<p>If you observe the above definition carefully, you will notice it is a concrete type, which is <code>&str</code>. However, for <code>AsRef</code> and <code>Borrow</code> traits, you will need to have a type that must implement them anyhow, therefore limiting the application and optimizations available.<p>Deref coercion is a powerful language feature if used correctly, you can read more about it <a href=https://dev.to/artechgit/rust-deref-coercion-simplifying-borrowing-and-dereferencing-1a4a>here</a><p>Now that we have built some understanding around it, let's quickly compare them through a simple table.<h2 id=comparison-table><a aria-label="Anchor link for: comparison-table" class=zola-anchor href=#comparison-table>Comparison Table</a></h2><table><thead><tr><th>Trait<th>Primary Purpose<th>Key Characteristics<tbody><tr><td><code>AsRef</code><td>Cheap reference conversions<td>- No guarantees about equality or hashing<br>- Useful for generic functions accepting references<tr><td><code>Borrow</code><td>Borrowed data equivalence<td>- Guarantees about equality and hashing<br>- Essential for collections types like HashMap/BtreeMap<tr><td><code>Deref</code><td>Smart pointer functionality<td>- Enables <code>*</code> operator<br>- Enables deref coercion<br>- Affects method resolution</table><h2 id=common-gotchas><a aria-label="Anchor link for: common-gotchas" class=zola-anchor href=#common-gotchas>Common Gotchas</a></h2><ol><li><strong>Deref Coercion Costs</strong></ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Multiple deref coercions can have performance implications
</span><span style=color:#fa6e32>let</span><span> s </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>Box</span><span style=color:#ed9366>::</span><span>new(</span><span style=color:#55b4d4;font-style:italic>String</span><span style=color:#ed9366>::</span><span>from(</span><span style=color:#86b300>"hello"</span><span>))</span><span style=color:#61676ccc>;
</span><span style=color:#f07171>takes_str</span><span>(</span><span style=color:#ed9366>&</span><span>s)</span><span style=color:#61676ccc>;  </span><span style=color:#abb0b6;font-style:italic>// Box -> String -> str, two dereferences
</span></code></pre><ol start=2><li><strong>Borrow vs AsRef Choice</strong></ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Wrong choice for HashMap key type
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>bad_design</span><span>&LTT</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>AsRef</span><span><</span><span style=color:#fa6e32>str</span><span>>>(</span><span style=color:#ff8f40>map</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>HashMap&LTT, </span><span style=color:#fa6e32>u32</span><span>>) {} </span><span style=color:#abb0b6;font-style:italic>// Won't work well
</span><span>
</span><span style=color:#abb0b6;font-style:italic>// Correct choice
</span><span style=color:#fa6e32>fn </span><span style=color:#f29718>good_design</span><span>&LTT</span><span style=color:#61676ccc>: </span><span>Borrow<</span><span style=color:#fa6e32>str</span><span>>>(</span><span style=color:#ff8f40>map</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span>HashMap&LTT, </span><span style=color:#fa6e32>u32</span><span>>) {}
</span></code></pre><ol start=3><li><strong>Deref for Non-Pointer Types</strong></ol><pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// Generally avoid implementing Deref for non-pointer-like types
</span><span style=color:#abb0b6;font-style:italic>// Could be confusing for other developers
</span><span style=color:#fa6e32>struct </span><span style=color:#399ee6>Seconds</span><span>(</span><span style=color:#fa6e32>u64</span><span>)</span><span style=color:#61676ccc>;
</span><span style=color:#abb0b6;font-style:italic>// Avoid this:
</span><span style=color:#fa6e32>impl </span><span>Deref </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>Seconds </span><span>{
</span><span>    </span><span style=color:#fa6e32>type </span><span style=color:#399ee6>Target </span><span style=color:#ed9366>= </span><span style=color:#fa6e32>u64</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>deref</span><span>(</span><span style=color:#ed9366>&</span><span style=color:#ff8f40>self</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>u64 </span><span>{ </span><span style=color:#ed9366>&</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0 </span><span>}
</span><span>}
</span></code></pre><h2 id=summary><a aria-label="Anchor link for: summary" class=zola-anchor href=#summary>Summary</a></h2><p>This overview covers the main differences and use cases for these three important Rust traits. The key is understanding their specific purposes and contracts to use them effectively in your code.</section></article></main><div class=giscus></div><script async crossorigin issue-term=pathname repo=not-matthias/apollo src=https://utteranc.es/client.js theme=github-light></script></div>