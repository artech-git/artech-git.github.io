<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
         Dealing with Panics ðŸ”¥ in async rust ðŸ¦€
        
    </title><meta content="Dealing with Panics ðŸ”¥ in async rust ðŸ¦€" property=og:title><meta content="Welcome to my personal site where I share my thoughts, projects, and experiences." property=og:description><meta content="Welcome to my personal site where I share my thoughts, projects, and experiences." name=description><link href=/icon/favicon.png rel=icon type=image/png><link href=https://artech-git.github.io/fonts.css rel=stylesheet><script src=https://artech-git.github.io/js/codeblock.js></script><script src=https://artech-git.github.io/js/toc.js></script><script src=https://artech-git.github.io/js/note.js></script><script>MathJax={tex:{inlineMath:[[`\$`,`\$`],[`\\\\(`,`\\\\)`]]}}</script><script async id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link href=https://artech-git.github.io/atom.xml rel=alternate title=artech type=application/atom+xml><link href=https://artech-git.github.io/theme/light.css rel=stylesheet><link href=https://artech-git.github.io/theme/dark.css id=darkModeStyle rel=stylesheet><script src=https://artech-git.github.io/js/themetoggle.js></script><script>setTheme(getSavedTheme())</script><link href=https://artech-git.github.io/main.css media=screen rel=stylesheet><body><div class=content><header><div class=main><a href=https://artech-git.github.io/>artech</a><div class=socials><a class=social href=https://github.com/artech-git/ rel=me> <img alt=github src=https://artech-git.github.io/social_icons/github.svg> </a><a class=social href=https://www.linkedin.com/in/prabhat25/ rel=me> <img alt=linked src=https://artech-git.github.io/social_icons/linkedin.svg> </a></div></div><nav><a href=https://artech-git.github.io/posts style=margin-left:.5em>/posts</a><a href=https://artech-git.github.io/projects style=margin-left:.5em>/projects</a><a href=https://artech-git.github.io/courses style=margin-left:.5em>/courses</a><a href=https://artech-git.github.io/books style=margin-left:.5em>/books</a><a href=https://artech-git.github.io/resume style=margin-left:.5em>/resume</a><a href=https://artech-git.github.io/talks style=margin-left:.5em>/talks</a><a href=https://artech-git.github.io/certs style=margin-left:.5em>/certs</a><a href=https://artech-git.github.io/about style=margin-left:.5em>/about</a> |<a onclick="toggleTheme(); event.preventDefault();" href=# id=dark-mode-toggle> <img alt=Light id=sun-icon src=https://artech-git.github.io/feather/sun.svg style=filter:invert()> <img alt=Dark id=moon-icon src=https://artech-git.github.io/feather/moon.svg> </a><script>updateItemToggleTheme()</script></nav></header><main><article><div class=title><div class=page-header>Dealing with Panics ðŸ”¥ in async rust ðŸ¦€<span class=primary-color style=font-size:1.6em>.</span></div><div class=meta>Posted on <time>2024-12-08</time><span class=tags-label> :: Tags:</span><span class=tags> <a class=post-tag href=https://artech-git.github.io/tags/low-level-design/>low-level design</a>, <a class=post-tag href=https://artech-git.github.io/tags/programming/>programming</a>, <a class=post-tag href=https://artech-git.github.io/tags/coding/>coding</a> </span> :: <a rel="noopener noreferrer" href=https://github.com/artech-git/artech-git.github.io/tree/main/contentposts/async_panic_handling.md target=_blank> Source Code</a></div></div><div class=toc-container><h1 class=toc-title>Table of Contents</h1><ul class=toc-list><li><a href=https://artech-git.github.io/posts/async-panic-handling/#intro>Intro</a><li><a href=https://artech-git.github.io/posts/async-panic-handling/#problem-at-hand>Problem at Hand</a><li><a href=https://artech-git.github.io/posts/async-panic-handling/#async-runtime-and-panic-handling-strategy>Async Runtime and Panic Handling Strategy</a><li><a href=https://artech-git.github.io/posts/async-panic-handling/#std-panic-catch-unwind-to-your-rescue>std::panic::catch_unwind to your rescue</a><li><a href=https://artech-git.github.io/posts/async-panic-handling/#using-catch-unwind-with-your-futures>Using catch_unwind with your futures</a><li><a href=https://artech-git.github.io/posts/async-panic-handling/#panic-hooks>Panic hooks</a></ul></div><section class=body><h1 id=intro><a aria-label="Anchor link for: intro" class=zola-anchor href=#intro>Intro</a></h1><p>You might have come across the term "fearless concurrency" quite often if you have some background in Rust, but nothing is absolute in this world, and neither is concurrency. Additionally, it's very unlikely to find the term "<strong>fearless async concurrency</strong>" in Rust's ecosystem. Let's delve deeper into this.<h1 id=problem-at-hand><a aria-label="Anchor link for: problem-at-hand" class=zola-anchor href=#problem-at-hand>Problem at Hand</a></h1><p>While working with some async codebases, your logical definition of code might have some quirky possibility of panicking somewhere or at some part of the code. This could be anticipated in advance or maybe totally undetected. As illustrated with the example below, let's study it to find out more about it.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span>
</span><span>async </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>fetch_all_post</span><span>(</span><span style=color:#ff8f40>n</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u32</span><span>) {
</span><span>    </span><span style=color:#fa6e32>let</span><span> pagination_factor </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>4</span><span style=color:#61676ccc>; 
</span><span>    </span><span style=color:#fa6e32>let</span><span> pagination_stub_factor</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u32 </span><span style=color:#ed9366>= </span><span>(n </span><span style=color:#ed9366>/ </span><span style=color:#ff8f40>4</span><span>) </span><span style=color:#ed9366>as </span><span style=color:#fa6e32>u32</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> url </span><span style=color:#ed9366>= </span><span style=color:#f07171>format!</span><span>(</span><span style=color:#86b300>"https://random_domain.com/posts/pagination/</span><span style=color:#ff8f40>{}</span><span style=color:#86b300>"</span><span style=color:#61676ccc>,</span><span> pagination_stub_factor)</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#fa6e32>let</span><span> _res </span><span style=color:#ed9366>= </span><span>reqwest</span><span style=color:#ed9366>::</span><span>get(url</span><span style=color:#ed9366>.</span><span style=color:#f07171>into</span><span>())</span><span style=color:#ed9366>.</span><span>await</span><span style=color:#61676ccc>; 
</span><span>}
</span><span>
</span></code></pre><p>In the above example, we can see that we are trying to determine the pagination factor for a given URL (just as an example). If you are a bit experienced, you may have already spotted the problem present here! Let's look at those:<ul><li>What if <code>pagination_factor</code> is greater than <code>n</code>?<li>There could be problems in casting <code>f32</code> to <code>u32</code>.</ul><p>We will focus on the first point since it's easier to prove the point. Imagine that you update your code with some assert statement like this, which could panic if any value we supply is checked against <code>pagination_factor</code>.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span>async </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>fetch_all_post</span><span>(</span><span style=color:#ff8f40>n</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u32</span><span>) {
</span><span>    </span><span style=color:#fa6e32>let</span><span> pagination_factor </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>4</span><span style=color:#61676ccc>; 
</span><span>    </span><span style=color:#f07171>assert!</span><span>(n </span><span style=color:#ed9366>>=</span><span> pagination_factor)</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> pagination_stub_factor</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u32 </span><span style=color:#ed9366>= </span><span>(n </span><span style=color:#ed9366>/ </span><span style=color:#ff8f40>4</span><span>) </span><span style=color:#ed9366>as </span><span style=color:#fa6e32>u32</span><span style=color:#61676ccc>;
</span><span>    </span><span style=color:#fa6e32>let</span><span> url </span><span style=color:#ed9366>= </span><span style=color:#f07171>format!</span><span>(</span><span style=color:#86b300>"https://random_domain.com/posts/pagination/</span><span style=color:#ff8f40>{}</span><span style=color:#86b300>"</span><span style=color:#61676ccc>,</span><span> pagination_stub_factor)</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#fa6e32>let</span><span> _res </span><span style=color:#ed9366>= </span><span>reqwest</span><span style=color:#ed9366>::</span><span>get(url</span><span style=color:#ed9366>.</span><span style=color:#f07171>into</span><span>())</span><span style=color:#ed9366>.</span><span>await</span><span style=color:#61676ccc>; 
</span><span>}
</span></code></pre><p>Hmm, looks fine now but we still havn't eliminated the possibilty of panicking in our code<pre class=language-bash data-lang=bash style=color:#61676c;background-color:#fafafa><code class=language-bash data-lang=bash><span>    </span><span style=color:#f29718>Finished </span><span>`</span><span style=color:#f29718>dev</span><span>` profile </span><span style=color:#fa6e32>[</span><span>unoptimized + debuginfo</span><span style=color:#fa6e32>]</span><span> target(s) </span><span style=color:#f29718>in</span><span> 2.25s
</span><span>     </span><span style=color:#f29718>Running </span><span>`</span><span style=color:#f29718>target/debug/playground</span><span>`
</span><span style=color:#f29718>thread </span><span style=color:#86b300>'main'</span><span> panicked at src/main.rs:16:5:
</span><span style=color:#f29718>assertion</span><span> failed: n </span><span style=color:#ed9366>></span><span>= pagination_factor
</span></code></pre><p>Somehow we should be able to control the consequence of panic, we will study those in the coming sections.<h1 id=async-runtime-and-panic-handling-strategy><a aria-label="Anchor link for: async-runtime-and-panic-handling-strategy" class=zola-anchor href=#async-runtime-and-panic-handling-strategy>Async Runtime and Panic Handling Strategy</a></h1><p>If you are writing async Rust, then you have to choose an async executor which will run your futures/async tasks forward. Below is a list of some widely adopted and often used executors:<ul><li>tokio<li>async-std<li>smol-rs</ul><p>Each async executor has its own strategy for dealing with panics that occur within an async block.<p>With Tokio, if a panic occurs, it isolates the given task. The runtime doesn't shut down (though this behavior can be modified) and continues to operate while printing the standard error message to standard out, simply restarting.<p>The case with async-std is the same as above, where tasks are isolated based on how they are spawned. If a panic occurs in some task, it won't crash the entire runtime, and other tasks would simply restart and continue from that point onwards.<p>For smol-rs, it deals with panics similarly to how the above two handle them, except with some internal exceptions.<p>But mostly, for all the tasks (futures) which are spawned using these runtimes, a handle is returned which can carry the panic message as an <code>Err</code> variant as described below.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>//assuming we are in some async context or block already 
</span><span>
</span><span style=color:#fa6e32>let</span><span> join_handle</span><span style=color:#61676ccc>: </span><span>tokio</span><span style=color:#ed9366>::</span><span>task</span><span style=color:#ed9366>::</span><span>JoinHandle<()> </span><span style=color:#ed9366>= </span><span>tokio</span><span style=color:#ed9366>::</span><span>task</span><span style=color:#ed9366>::</span><span>spawn(
</span><span>    async </span><span style=color:#fa6e32>move </span><span>{ 
</span><span>        </span><span style=color:#f07171>panic!</span><span>(</span><span style=color:#86b300>"some error"</span><span>) </span><span style=color:#abb0b6;font-style:italic>//we panic inside our task 
</span><span>    }
</span><span>    )</span><span style=color:#61676ccc>;
</span><span style=color:#abb0b6;font-style:italic>// we get a result type whose error variant is of std::any::Any type
</span><span style=color:#fa6e32>let</span><span> res</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Result</span><span><(), </span><span style=color:#55b4d4;font-style:italic>Box</span><span>&LTdyn std</span><span style=color:#ed9366>::</span><span>any</span><span style=color:#ed9366>::</span><span>Any>> </span><span style=color:#ed9366>=</span><span> join_handle</span><span style=color:#ed9366>.</span><span>await</span><span style=color:#61676ccc>; 
</span></code></pre><p>Looking at the above example, we find that during panics, it gets converted to the trait object <code>std::any::Any</code>, which can universally represent any type. Later, you may downcast it based on your error handling strategy. As you can see, the runtime does give you these abilities, and this is valid for most runtimes since these tasks are isolated from each other.<p>Note: Error types passed from <code>panic!(..)</code> might look easy to deal with, but it is an expensive operation to convert from <code>Box&LTdyn std::any::Any></code> to some other type. If you are designing your application to be performant, you may require something more direct that you can control.<h1 id=std-panic-catch-unwind-to-your-rescue><a aria-label="Anchor link for: std-panic-catch-unwind-to-your-rescue" class=zola-anchor href=#std-panic-catch-unwind-to-your-rescue>std::panic::catch_unwind to your rescue</a></h1><p>We briefly looked over how runtimes deal with futures that may panic, but luckily we have more control already available if you wish to avoid the route of runtime handling panics of your future.<p>To give it a simple start, there can be some suspicious part of the code where we suspect that it might panic somehow! Let's check out the previous example again.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#ff8f40>1</span><span> async </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>fetch_all_post</span><span>(</span><span style=color:#ff8f40>n</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u32</span><span>) {
</span><span style=color:#ff8f40>2    </span><span style=color:#fa6e32>let</span><span> pagination_factor </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>4</span><span style=color:#61676ccc>; 
</span><span style=color:#ff8f40>3    </span><span style=color:#f07171>assert!</span><span>(n </span><span style=color:#ed9366>>=</span><span> pagination_factor)</span><span style=color:#61676ccc>;
</span><span style=color:#ff8f40>4    </span><span style=color:#fa6e32>let</span><span> pagination_stub_factor</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u32 </span><span style=color:#ed9366>= </span><span>(n </span><span style=color:#ed9366>/ </span><span style=color:#ff8f40>4</span><span>) </span><span style=color:#ed9366>as </span><span style=color:#fa6e32>u32</span><span style=color:#61676ccc>;
</span><span style=color:#ff8f40>5    </span><span style=color:#fa6e32>let</span><span> url </span><span style=color:#ed9366>= </span><span style=color:#f07171>format!</span><span>(</span><span style=color:#86b300>"https://random_domain.com/posts/pagination/</span><span style=color:#ff8f40>{}</span><span style=color:#86b300>"</span><span style=color:#61676ccc>,</span><span> pagination_stub_factor)</span><span style=color:#61676ccc>;
</span><span style=color:#ff8f40>6
</span><span style=color:#ff8f40>7    </span><span style=color:#fa6e32>let</span><span> _res </span><span style=color:#ed9366>= </span><span>reqwest</span><span style=color:#ed9366>::</span><span>get(url</span><span style=color:#ed9366>.</span><span style=color:#f07171>into</span><span>())</span><span style=color:#ed9366>.</span><span>await</span><span style=color:#61676ccc>; 
</span><span>}
</span></code></pre><p>Here we know line number 3 might panic based on user input. To prevent this from happening, we can simply wrap this part of the code in the <code>std::panic::catch_unwind</code> function like this:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#ff8f40>1</span><span> async </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>fetch_all_post</span><span>(</span><span style=color:#ff8f40>n</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u32</span><span>) {
</span><span style=color:#ff8f40>2    </span><span style=color:#fa6e32>let</span><span> url </span><span style=color:#ed9366>= </span><span>std</span><span style=color:#ed9366>::</span><span>panic</span><span style=color:#ed9366>::</span><span>catch_unwind(||
</span><span style=color:#ff8f40>3        </span><span style=color:#fa6e32>let</span><span> pagination_factor </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>4</span><span style=color:#61676ccc>; 
</span><span style=color:#ff8f40>4        </span><span style=color:#f07171>assert!</span><span>(n </span><span style=color:#ed9366>>=</span><span> pagination_factor)</span><span style=color:#61676ccc>;
</span><span style=color:#ff8f40>5        </span><span style=color:#fa6e32>let</span><span> pagination_stub_factor</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u32 </span><span style=color:#ed9366>= </span><span>(n </span><span style=color:#ed9366>/ </span><span style=color:#ff8f40>4</span><span>) </span><span style=color:#ed9366>as </span><span style=color:#fa6e32>u32</span><span style=color:#61676ccc>;
</span><span style=color:#ff8f40>6        </span><span style=color:#f07171>format!</span><span>(</span><span style=color:#86b300>"https://random_domain.com/posts/pagination/</span><span style=color:#ff8f40>{}</span><span style=color:#86b300>"</span><span style=color:#61676ccc>,</span><span> pagination_stub_factor)
</span><span style=color:#ff8f40>7    </span><span>)</span><span style=color:#61676ccc>;
</span><span style=color:#ff8f40>8
</span><span style=color:#ff8f40>9    </span><span style=color:#fa6e32>match</span><span> url_block {
</span><span style=color:#ff8f40>10        </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(url_val) </span><span style=color:#ed9366>=> </span><span>{
</span><span style=color:#ff8f40>11            </span><span style=color:#fa6e32>let</span><span> _res </span><span style=color:#ed9366>= </span><span>reqwest</span><span style=color:#ed9366>::</span><span>get(url_val</span><span style=color:#ed9366>.</span><span style=color:#f07171>into</span><span>())</span><span style=color:#ed9366>.</span><span>await</span><span style=color:#61676ccc>; 
</span><span style=color:#ff8f40>12        </span><span>}
</span><span style=color:#ff8f40>13        </span><span style=color:#55b4d4;font-style:italic>Err</span><span>(err) </span><span style=color:#ed9366>=> </span><span>{
</span><span style=color:#ff8f40>14            </span><span style=color:#f07171>println!</span><span>(</span><span style=color:#86b300>"some error: </span><span style=color:#ff8f40>{}</span><span style=color:#86b300>"</span><span style=color:#61676ccc>,</span><span> err)</span><span style=color:#61676ccc>; 
</span><span style=color:#ff8f40>15        </span><span>}
</span><span style=color:#ff8f40>16    </span><span>}</span><span style=color:#61676ccc>;
</span><span>}
</span><span>So what</span><span style=color:#fa6e32>'s</span><span> changed now ðŸ¤”</span><span style=color:#ed9366>?</span><span> We wrapped lines </span><span style=color:#ff8f40>2</span><span style=color:#ed9366>-</span><span style=color:#ff8f40>5 </span><span>(of the original method) into the `catch_unwind` method and returned the computed </span><span style=color:#ff8f40>URL</span><span> by performing matching on it since it is a result </span><span style=color:#fa6e32>type</span><span style=color:#ed9366>.</span><span> If line </span><span style=color:#ff8f40>4</span><span> panics</span><span style=color:#61676ccc>,</span><span> we won</span><span style=color:#fa6e32>'t</span><span> crash or show an error message on our async runtime</span><span style=color:#ed9366>.</span><span> Instead</span><span style=color:#61676ccc>,</span><span> this will be handled within our code by ourselves</span><span style=color:#ed9366>.
</span><span style=color:#ed9366><</span><span>br</span><span style=color:#ed9366>/>
</span><span>Let</span><span style=color:#fa6e32>'s</span><span> now check out the definition of `std</span><span style=color:#ed9366>::</span><span>panic</span><span style=color:#ed9366>::</span><span>catch_unwind` from the std library</span><span style=color:#61676ccc>:
</span><span>
</span><span>```rust
</span><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>catch_unwind</span><span>&LTF</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>FnOnce</span><span>() </span><span style=color:#61676ccc>-></span><span> R </span><span style=color:#ed9366>+</span><span> UnwindSafe, R>(</span><span style=color:#ff8f40>f</span><span style=color:#61676ccc>:</span><span> F) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span>&LTR>
</span></code></pre><p>Here you will observe two generics: <code>F</code>, which accepts a closure and returns <code>R</code>, which should also implement the <code>UnwindSafe</code> trait (we will discuss this in more detail). Interestingly, the return type here has to be the following:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub type </span><span style=color:#399ee6>Result</span><span style=color:#ed9366><</span><span>T</span><span style=color:#ed9366>> = </span><span style=color:#55b4d4;font-style:italic>Result</span><span>&LTT, </span><span style=color:#55b4d4;font-style:italic>Box</span><span>&LTdyn Any </span><span style=color:#ed9366>+ </span><span style=color:#55b4d4;font-style:italic>Send </span><span style=color:#ed9366>+ </span><span style=color:#fa6e32>'static</span><span>>></span><span style=color:#61676ccc>;
</span></code></pre><p>Basically, the Result type is aliased to have the error variant be thread-safe if encountered.<p>Hmm, so now you see how powerful <code>std::panic::catch_unwind</code> can be. Remember, this is just a single example; there could be several more possibilities depending on how you wish to handle such panics.<h1 id=using-catch-unwind-with-your-futures><a aria-label="Anchor link for: using-catch-unwind-with-your-futures" class=zola-anchor href=#using-catch-unwind-with-your-futures>Using catch_unwind with your futures</a></h1><p>Earlier, we saw how we can manually establish control over panics and produce a Result type as a consequence, but something even more convenient is already available for you from the <code>Futures</code> crate. This is the <a href=https://docs.rs/futures/latest/futures/future/trait.FutureExt.html#method.catch_unwind><code>catch_unwind()</code></a> method, which creates an intermediate object <a href=https://docs.rs/futures/latest/futures/future/struct.CatchUnwind.html><code>CatchUnwind&LTFut></code></a> that implements <a href=https://docs.rs/futures/latest/futures/future/trait.Future.html><code>futures::future::Future</code></a>. Hence, after awaiting it, it produces a result as shown in the description below.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>impl</span><span>&LTFut> Future </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>CatchUnwind</span><span>&LTFut>
</span><span style=color:#fa6e32>where
</span><span>    Fut</span><span style=color:#61676ccc>:</span><span> Future + UnwindSafe,
</span><span>{
</span><span>    </span><span style=color:#abb0b6;font-style:italic>//notice the output type here 
</span><span>    </span><span style=color:#fa6e32>type </span><span style=color:#399ee6>Output </span><span style=color:#ed9366>= </span><span style=color:#55b4d4;font-style:italic>Result</span><span><</span><span style=color:#fa6e32>Fut</span><span style=color:#ed9366>::</span><span>Output, </span><span style=color:#55b4d4;font-style:italic>Box</span><span>&LTdyn Any </span><span style=color:#ed9366>+ </span><span style=color:#55b4d4;font-style:italic>Send</span><span>>></span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>poll</span><span>(</span><span style=color:#ff8f40>self</span><span>: Pin<</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut Self</span><span>>, </span><span style=color:#ff8f40>cx</span><span style=color:#61676ccc>: </span><span style=color:#ed9366>&</span><span style=color:#fa6e32>mut </span><span>Context<'</span><span style=color:#ed9366>_</span><span>>) </span><span style=color:#61676ccc>-> </span><span>Poll<</span><span style=color:#fa6e32>Self</span><span style=color:#ed9366>::</span><span>Output> {
</span><span>        </span><span style=color:#ed9366>...
</span><span>    }
</span><span>}
</span></code></pre><p>For the associated type <code>Output</code>, it returns the <code>Ok</code> variant with the output for which this was called, and the <code>Err</code> variant is again a <code>Box&LTdyn Any + Send></code> trait object that can be sent anywhere. Now let's see it in action.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>use </span><span>futures</span><span style=color:#ed9366>::</span><span>future</span><span style=color:#ed9366>::</span><span>FutureExt</span><span style=color:#61676ccc>; 
</span><span>
</span><span style=color:#ff8f40>1</span><span> async </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>fetch_all_post</span><span>(</span><span style=color:#ff8f40>n</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u32</span><span>) {
</span><span style=color:#ff8f40>2
</span><span style=color:#ff8f40>3    </span><span style=color:#fa6e32>let</span><span> catch_url_block</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Result</span><span><</span><span style=color:#55b4d4;font-style:italic>String</span><span>, </span><span style=color:#55b4d4;font-style:italic>Box</span><span>&LTdyn Any </span><span style=color:#ed9366>+ </span><span style=color:#55b4d4;font-style:italic>Send</span><span>>> </span><span style=color:#ed9366>=</span><span> async </span><span style=color:#fa6e32>move </span><span>{
</span><span style=color:#ff8f40>4       </span><span style=color:#fa6e32>let</span><span> pagination_factor </span><span style=color:#ed9366>= </span><span style=color:#ff8f40>4</span><span style=color:#61676ccc>; 
</span><span style=color:#ff8f40>5       </span><span style=color:#f07171>assert!</span><span>(n </span><span style=color:#ed9366>>=</span><span> pagination_factor)</span><span style=color:#61676ccc>;
</span><span style=color:#ff8f40>6       </span><span style=color:#fa6e32>let</span><span> pagination_stub_factor</span><span style=color:#61676ccc>: </span><span style=color:#fa6e32>u32 </span><span style=color:#ed9366>= </span><span>(n </span><span style=color:#ed9366>/ </span><span style=color:#ff8f40>4</span><span>) </span><span style=color:#ed9366>as </span><span style=color:#fa6e32>u32</span><span style=color:#61676ccc>;
</span><span style=color:#ff8f40>7       </span><span style=color:#fa6e32>let</span><span> url </span><span style=color:#ed9366>= </span><span style=color:#f07171>format!</span><span>(</span><span style=color:#86b300>"https://random_domain.com/posts/pagination/</span><span style=color:#ff8f40>{}</span><span style=color:#86b300>"</span><span style=color:#61676ccc>,</span><span> pagination_stub_factor)</span><span style=color:#61676ccc>;
</span><span style=color:#ff8f40>8    </span><span>}</span><span style=color:#ed9366>.</span><span style=color:#f07171>catch_unwind</span><span>()</span><span style=color:#ed9366>.</span><span>await</span><span style=color:#61676ccc>;      </span><span style=color:#abb0b6;font-style:italic>// we apply catch_unwind to this
</span><span style=color:#ff8f40>9
</span><span style=color:#ff8f40>10    </span><span style=color:#fa6e32>match</span><span> url_block {
</span><span style=color:#ff8f40>10        </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(url_val) </span><span style=color:#ed9366>=> </span><span>{
</span><span style=color:#ff8f40>11            </span><span style=color:#fa6e32>let</span><span> _res </span><span style=color:#ed9366>= </span><span>reqwest</span><span style=color:#ed9366>::</span><span>get(url_val</span><span style=color:#ed9366>.</span><span style=color:#f07171>into</span><span>())</span><span style=color:#ed9366>.</span><span>await</span><span style=color:#61676ccc>; 
</span><span style=color:#ff8f40>12        </span><span>}
</span><span style=color:#ff8f40>13        </span><span style=color:#55b4d4;font-style:italic>Err</span><span>(err) </span><span style=color:#ed9366>=> </span><span>{
</span><span style=color:#ff8f40>14            </span><span style=color:#f07171>println!</span><span>(</span><span style=color:#86b300>"some error: </span><span style=color:#ff8f40>{}</span><span style=color:#86b300>"</span><span style=color:#61676ccc>,</span><span> err)</span><span style=color:#61676ccc>; 
</span><span style=color:#ff8f40>15        </span><span>}
</span><span style=color:#ff8f40>16    </span><span>}</span><span style=color:#61676ccc>;
</span><span style=color:#ff8f40>17 </span><span>}
</span></code></pre><p>Look at line number 8, you will find that we have used <code>.catch_unwind()</code>. Now we can also call <code>.await</code> on the <code>CatchUnwind</code> object. We can apply <code>catch_unwind</code> on any type that implements the <code>Future</code> trait. This can be smartly chained with other futures to create a more complex expression that can be later awaited for a response.<p>Let's check out an example of <code>catch_unwind</code> with streams:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#ff8f40>1 
</span><span style=color:#ff8f40>2 </span><span style=color:#fa6e32>let mut</span><span> client </span><span style=color:#ed9366>= </span><span>futures</span><span style=color:#ed9366>::</span><span>stream</span><span style=color:#ed9366>::</span><span>unfold(</span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>, </span><span>|</span><span style=color:#ff8f40>count</span><span>| async </span><span style=color:#fa6e32>move </span><span>{ 
</span><span style=color:#ff8f40>3     </span><span style=color:#fa6e32>let</span><span> next_count </span><span style=color:#ed9366>=</span><span> count </span><span style=color:#ed9366>+ </span><span style=color:#ff8f40>1</span><span style=color:#61676ccc>; 
</span><span style=color:#ff8f40>4    </span><span style=color:#abb0b6;font-style:italic>// peform some expensive work ...
</span><span style=color:#ff8f40>5    </span><span style=color:#55b4d4;font-style:italic>Some</span><span>((count</span><span style=color:#61676ccc>,</span><span> next_count)) </span><span style=color:#abb0b6;font-style:italic>// this will return count from it
</span><span style=color:#ff8f40>6 </span><span>})</span><span style=color:#61676ccc>;
</span><span style=color:#ff8f40>7
</span><span style=color:#ff8f40>8 </span><span style=color:#fa6e32>let mut</span><span> responses</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Vec</span><span><</span><span style=color:#fa6e32>i32</span><span>> </span><span style=color:#ed9366>=</span><span> client
</span><span style=color:#ff8f40>9        </span><span style=color:#ed9366>.</span><span style=color:#f07171>catch_unwind</span><span>()
</span><span style=color:#ff8f40>10        </span><span style=color:#ed9366>.</span><span style=color:#f07171>filter_map</span><span>(|</span><span style=color:#ff8f40>val</span><span>| val</span><span style=color:#ed9366>.</span><span style=color:#f07171>ok</span><span>()) </span><span style=color:#abb0b6;font-style:italic>// convert Result&LTi32, Box&LTdyn Any + Send>> to Option&LTi32>
</span><span style=color:#ff8f40>11        </span><span style=color:#ed9366>.</span><span style=color:#f07171>take</span><span>(</span><span style=color:#ff8f40>50</span><span>)
</span><span style=color:#ff8f40>12        </span><span style=color:#ed9366>.</span><span style=color:#f07171>collect</span><span>()
</span><span style=color:#ff8f40>13        </span><span style=color:#ed9366>.</span><span>await</span><span style=color:#61676ccc>;
</span><span style=color:#ff8f40>14
</span></code></pre><p>In the above example, you see how we are using streams in the future to compute something. You might wonder how <code>catch_unwind</code> is implementable on something like <code>future::stream::StreamExt</code>. Note that this method is also available under <a href=https://docs.rs/futures/latest/futures/stream/trait.StreamExt.html#method.catch_unwind><code>futures::stream::StreamExt</code></a>. On line 10, we convert <code>Result&LTi32, Box&LTdyn Any + Send>></code> to <code>Option&LTi32></code> type simply because the <a href=https://docs.rs/futures/latest/futures/stream/trait.StreamExt.html#method.filter_map><code>filter_map</code></a> method requires us to pass any data encapsulated as an option type. Then, we take 50 of those and collect them.<p>This example was too straightforward, honestly, but the quirky nature of this method is not yet revealed. Let's check out a more realistic example that does something more interesting...<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>let mut</span><span> client </span><span style=color:#ed9366>= </span><span>futures</span><span style=color:#ed9366>::</span><span>stream</span><span style=color:#ed9366>::</span><span>unfold(</span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>, </span><span>|</span><span style=color:#ff8f40>count</span><span>| async </span><span style=color:#fa6e32>move </span><span>{ 
</span><span>        </span><span style=color:#fa6e32>let</span><span> next_count </span><span style=color:#ed9366>=</span><span> count </span><span style=color:#ed9366>+ </span><span style=color:#ff8f40>1</span><span style=color:#61676ccc>; 
</span><span>        </span><span style=color:#fa6e32>let</span><span> url </span><span style=color:#ed9366>= </span><span style=color:#f07171>format!</span><span>(</span><span style=color:#86b300>"https://dummyjson.com/quotes/random"</span><span>)</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#fa6e32>let</span><span> req </span><span style=color:#ed9366>= </span><span>reqwest</span><span style=color:#ed9366>::</span><span>get(url)</span><span style=color:#ed9366>.</span><span>await</span><span style=color:#61676ccc>; </span><span style=color:#abb0b6;font-style:italic>// if this panics !
</span><span>        </span><span style=color:#55b4d4;font-style:italic>Some</span><span>((req</span><span style=color:#61676ccc>,</span><span> next_count))
</span><span>    })</span><span style=color:#61676ccc>;
</span><span>
</span><span>async </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>filter_posts</span><span>(
</span><span>    </span><span style=color:#ff8f40>catch_unwind_req</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Result</span><span><</span><span style=color:#55b4d4;font-style:italic>Result</span><span>&LTResponse, reqwest</span><span style=color:#ed9366>::</span><span>Error>, </span><span style=color:#55b4d4;font-style:italic>Box</span><span>&LTdyn Any </span><span style=color:#ed9366>+ </span><span style=color:#55b4d4;font-style:italic>Send</span><span>>>
</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#55b4d4;font-style:italic>String</span><span>> {
</span><span>    </span><span style=color:#fa6e32>match</span><span> catch_unwind_req {
</span><span>        </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(</span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(response)) </span><span style=color:#ed9366>=> </span><span>{
</span><span>            response</span><span style=color:#ed9366>.</span><span style=color:#f07171>text</span><span>()</span><span style=color:#ed9366>.</span><span>await</span><span style=color:#ed9366>.</span><span style=color:#f07171>ok</span><span>() </span><span style=color:#abb0b6;font-style:italic>//convert from Result&LTT,E> to Option&LTT>
</span><span>        }
</span><span>        </span><span style=color:#ed9366>_ => </span><span>{
</span><span>            </span><span style=color:#55b4d4;font-style:italic>None
</span><span>        }
</span><span>    }
</span><span>}
</span><span style=color:#fa6e32>let mut</span><span> responses</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Vec</span><span><</span><span style=color:#55b4d4;font-style:italic>String</span><span>> </span><span style=color:#ed9366>=</span><span> client
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>catch_unwind</span><span>()
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>filter_map</span><span>(filter_posts)
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>take</span><span>(</span><span style=color:#ff8f40>50</span><span>)
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>collect</span><span>()
</span><span>        </span><span style=color:#ed9366>.</span><span>await</span><span style=color:#61676ccc>;
</span><span>
</span></code></pre><p>Above is a good example regarding how <code>catch_unwind</code> could be potentially used in this!, Let's run this first<pre class=language-bash data-lang=bash style=color:#61676c;background-color:#fafafa><code class=language-bash data-lang=bash><span style=color:#ed9366>|     </span><span style=color:#f29718>fn</span><span> catch_unwind(self) </span><span style=color:#f29718>-</span><span style=color:#ed9366>></span><span> CatchUnwind</span><span style=color:#ed9366><</span><span>Self</span><span style=color:#ed9366>>
</span><span>     </span><span style=color:#ed9366>|        </span><span style=color:#f29718>------------</span><span> required by a bound in this associated function
</span><span style=color:#f29718>1324 </span><span style=color:#ed9366>|     </span><span style=color:#f29718>where
</span><span style=color:#f29718>1325 </span><span style=color:#ed9366>|         </span><span style=color:#f29718>Self:</span><span> Sized + std::panic::UnwindSafe,
</span><span>     </span><span style=color:#ed9366>|                       </span><span style=color:#f29718>^^^^^^^^^^^^^^^^^^^^^^</span><span> required by this bound in `</span><span style=color:#f29718>StreamExt::catch_unwind</span><span>`
</span><span>     
</span></code></pre><p>An error, hmmm... This is one of the problems that shows up. Let's revisit the definition of <code>catch_unwind</code> again:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>catch_unwind</span><span>&LTF</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>FnOnce</span><span>() </span><span style=color:#61676ccc>-></span><span> R </span><span style=color:#ed9366>+</span><span> UnwindSafe, R>(</span><span style=color:#ff8f40>f</span><span style=color:#61676ccc>:</span><span> F) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Result</span><span>&LTR>
</span></code></pre><p>You will see the <code>UnwindSafe</code> trait has to be applied to the return type! If you visit the definition of <a href=https://docs.rs/reqwest/latest/reqwest/struct.Response.html#impl-UnwindSafe-for-Response><code>reqwest::Response</code></a>, it contains a negative implementation for <code>!UnwindSafe</code>, hence it can't be sent across the <code>catch_unwind</code> boundary.<p>Now you might think, is there a way around this? Well, the answer is not that simple, but there exists a solution! Welcome <a href=https://doc.rust-lang.org/beta/std/panic/struct.AssertUnwindSafe.html#examples><code>std::panic::AssertUnwindSafe</code></a>.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub struct </span><span style=color:#399ee6>AssertUnwindSafe</span><span>&LTT>(pub T)</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>impl</span><span>&LTT> UnwindSafe </span><span style=color:#fa6e32>for </span><span style=color:#399ee6>AssertUnwindSafe</span><span>&LTT> {}
</span></code></pre><p>Type <code>std::panic::AssertUnwindSafe</code> implements the <code>UnwindSafe</code> trait even if the type contains <code>!UnwindSafe</code>. So, if a type implements <code>!UnwindSafe</code>, it can be wrapped in this type and returned from the <code>catch_unwind</code> boundary.<p>Coming back to our previous example, let's modify it to support the usage of <code>AssertUnwindSafe</code> here:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#abb0b6;font-style:italic>// we wrap our UnFold type into AssertUnwindSafe
</span><span style=color:#fa6e32>let mut</span><span> client </span><span style=color:#ed9366>=</span><span> AssertUnwindSafe(futures</span><span style=color:#ed9366>::</span><span>stream</span><span style=color:#ed9366>::</span><span>unfold(</span><span style=color:#ff8f40>0</span><span style=color:#61676ccc>, </span><span>|</span><span style=color:#ff8f40>count</span><span>| async </span><span style=color:#fa6e32>move </span><span>{ 
</span><span>        </span><span style=color:#fa6e32>let</span><span> next_count </span><span style=color:#ed9366>=</span><span> count </span><span style=color:#ed9366>+ </span><span style=color:#ff8f40>1</span><span style=color:#61676ccc>; 
</span><span>        </span><span style=color:#fa6e32>let</span><span> url </span><span style=color:#ed9366>= </span><span style=color:#f07171>format!</span><span>(</span><span style=color:#86b300>"https://dummyjson.com/quotes/random"</span><span>)</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#fa6e32>let</span><span> req </span><span style=color:#ed9366>= </span><span>reqwest</span><span style=color:#ed9366>::</span><span>get(url)</span><span style=color:#ed9366>.</span><span>await</span><span style=color:#61676ccc>; </span><span style=color:#abb0b6;font-style:italic>// if this panics !
</span><span>        </span><span style=color:#55b4d4;font-style:italic>Some</span><span>((req</span><span style=color:#61676ccc>,</span><span> next_count))
</span><span>    }))</span><span style=color:#61676ccc>;
</span><span>
</span><span>async </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>filter_posts</span><span>(
</span><span>    </span><span style=color:#ff8f40>catch_unwind_req</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Result</span><span><</span><span style=color:#55b4d4;font-style:italic>Result</span><span>&LTResponse, reqwest</span><span style=color:#ed9366>::</span><span>Error>, </span><span style=color:#55b4d4;font-style:italic>Box</span><span><(dyn Any + Send + </span><span style=color:#fa6e32>'static</span><span>)>>
</span><span>) </span><span style=color:#61676ccc>-> </span><span style=color:#55b4d4;font-style:italic>Option</span><span><</span><span style=color:#55b4d4;font-style:italic>String</span><span>> {
</span><span>    </span><span style=color:#fa6e32>match</span><span> catch_unwind_req {
</span><span>        </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(</span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(response)) </span><span style=color:#ed9366>=> </span><span>{
</span><span>            response</span><span style=color:#ed9366>.</span><span style=color:#ff8f40>0.</span><span style=color:#f07171>text</span><span>()</span><span style=color:#ed9366>.</span><span>await</span><span style=color:#ed9366>.</span><span style=color:#f07171>ok</span><span>() </span><span style=color:#abb0b6;font-style:italic>//convert from Result&LTT,E> to Option&LTT>
</span><span>        }
</span><span>        </span><span style=color:#ed9366>_ => </span><span>{
</span><span>            </span><span style=color:#55b4d4;font-style:italic>None
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style=color:#fa6e32>let mut</span><span> responses</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Vec</span><span><</span><span style=color:#55b4d4;font-style:italic>String</span><span>> </span><span style=color:#ed9366>=</span><span> client
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>catch_unwind</span><span>() </span><span style=color:#abb0b6;font-style:italic>// check each post incoming
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>filter_map</span><span>(filter_posts)
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>take</span><span>(</span><span style=color:#ff8f40>50</span><span>)
</span><span>        </span><span style=color:#ed9366>.</span><span style=color:#f07171>collect</span><span>()
</span><span>        </span><span style=color:#ed9366>.</span><span>await</span><span style=color:#61676ccc>;
</span></code></pre><p>We have modified the <code>client</code> type to be wrapped under <code>AssertUnwindSafe</code>. Under the hood, the <code>futures::stream::unfold</code> method returns an object <a href=https://docs.rs/futures/latest/futures/stream/struct.Unfold.html><code>future::stream::Unfold</code></a>. Here, we have also utilized <code>filter_map</code> for filtering out, but there is a catch! Let's see that too!<p>If we explicitly perform a panic just for the sake of testing, we will find something very interesting happening. The example below is taken from the official docs!<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>use </span><span>futures</span><span style=color:#ed9366>::</span><span>stream</span><span style=color:#ed9366>::</span><span>{</span><span style=color:#55b4d4;font-style:italic>self</span><span style=color:#61676ccc>,</span><span> StreamExt}</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>let</span><span> stream </span><span style=color:#ed9366>= </span><span>stream</span><span style=color:#ed9366>::</span><span>iter(</span><span style=color:#f07171>vec!</span><span>[</span><span style=color:#55b4d4;font-style:italic>Some</span><span>(</span><span style=color:#ff8f40>10</span><span>)</span><span style=color:#61676ccc>, </span><span style=color:#55b4d4;font-style:italic>None</span><span style=color:#61676ccc>, </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(</span><span style=color:#ff8f40>11</span><span>)])</span><span style=color:#61676ccc>;
</span><span style=color:#abb0b6;font-style:italic>// Panic on second element
</span><span style=color:#fa6e32>let</span><span> stream_panicking </span><span style=color:#ed9366>=</span><span> stream</span><span style=color:#ed9366>.</span><span style=color:#f07171>map</span><span>(|</span><span style=color:#ff8f40>o</span><span>| o</span><span style=color:#ed9366>.</span><span style=color:#f07171>unwrap</span><span>())</span><span style=color:#61676ccc>;
</span><span style=color:#abb0b6;font-style:italic>// Collect all the results
</span><span style=color:#fa6e32>let</span><span> stream </span><span style=color:#ed9366>=</span><span> stream_panicking</span><span style=color:#ed9366>.</span><span style=color:#f07171>catch_unwind</span><span>()</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#fa6e32>let</span><span> results</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Vec</span><span><</span><span style=color:#55b4d4;font-style:italic>Result</span><span><</span><span style=color:#fa6e32>i32</span><span>, </span><span style=color:#ed9366>_</span><span>>> </span><span style=color:#ed9366>=</span><span> stream</span><span style=color:#ed9366>.</span><span style=color:#f07171>collect</span><span>()</span><span style=color:#ed9366>.</span><span>await</span><span style=color:#61676ccc>;
</span><span style=color:#fa6e32>match</span><span> results[</span><span style=color:#ff8f40>0</span><span>] {
</span><span>    </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(</span><span style=color:#ff8f40>10</span><span>) </span><span style=color:#ed9366>=> </span><span>{}
</span><span>    </span><span style=color:#ed9366>_ => </span><span style=color:#f07171>panic!</span><span>(</span><span style=color:#86b300>"unexpected result!"</span><span>)</span><span style=color:#61676ccc>,
</span><span>}
</span><span style=color:#f07171>assert!</span><span>(results[</span><span style=color:#ff8f40>1</span><span>]</span><span style=color:#ed9366>.</span><span style=color:#f07171>is_err</span><span>())</span><span style=color:#61676ccc>;
</span><span style=color:#f07171>assert_eq!</span><span>(results</span><span style=color:#ed9366>.</span><span style=color:#f07171>len</span><span>()</span><span style=color:#61676ccc>, </span><span style=color:#ff8f40>2</span><span>)</span><span style=color:#61676ccc>;
</span></code></pre><p>This is something where you can find it problematic to deal with. The official docs for <a href=https://docs.rs/futures/latest/futures/prelude/stream/trait.StreamExt.html#method.catch_unwind><code>futures::stream::catch_unwind</code></a> mention the following:<p><strong>Caught panic (if any) will be the last element of the resulting stream</strong><p>So you have to know how to use it correctly if you wish to utilize this.<h1 id=panic-hooks><a aria-label="Anchor link for: panic-hooks" class=zola-anchor href=#panic-hooks>Panic hooks</a></h1><p>Remember the topic we covered earlier about async runtime panic handling? That topic only contained information regarding how the runtime internally handled panics. For example, to go more in-depth, the Tokio runtime builder object <a href=https://docs.rs/tokio/latest/tokio/runtime/struct.Builder.html#method.unhandled_panic>tokio::runtime::Builder::unhandled_panic</a> gives you a method for dealing with panics that might happen within Tokio's async runtime context. Though unstable, it is still available.<p>Interestingly, we have another technique available specifically to deal with this: introducing panic hooks.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span style=color:#fa6e32>pub fn </span><span style=color:#f29718>set_hook</span><span>(</span><span style=color:#ff8f40>hook</span><span style=color:#61676ccc>: </span><span style=color:#55b4d4;font-style:italic>Box</span><span>&LTdyn </span><span style=color:#55b4d4;font-style:italic>Fn</span><span>(</span><span style=color:#ed9366>&</span><span>PanicHookInfo<'</span><span style=color:#ed9366>_</span><span>>) </span><span style=color:#ed9366>+ </span><span style=color:#55b4d4;font-style:italic>Sync </span><span style=color:#ed9366>+ </span><span style=color:#55b4d4;font-style:italic>Send </span><span style=color:#ed9366>+ </span><span style=color:#fa6e32>'static</span><span>>)
</span></code></pre><p>If somewhere within your codebase there happens to be a panic, this hook will be called automatically. The signature of this method is straightforward; it accepts a boxed closure with a signature where the type must be <code>Send</code> and <code>Sync</code> compatible. Let's see an example of this.<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span>    std</span><span style=color:#ed9366>::</span><span>panic</span><span style=color:#ed9366>::</span><span>set_hook(</span><span style=color:#55b4d4;font-style:italic>Box</span><span style=color:#ed9366>::</span><span>new(|</span><span style=color:#ff8f40>panic_info</span><span>| {
</span><span>    
</span><span>        </span><span style=color:#fa6e32>let</span><span> timestamp </span><span style=color:#ed9366>= </span><span>chrono</span><span style=color:#ed9366>::</span><span>Local</span><span style=color:#ed9366>::</span><span>now()</span><span style=color:#ed9366>.</span><span style=color:#f07171>format</span><span>(</span><span style=color:#86b300>"%Y-%m-%d %H:%M:%S"</span><span>)</span><span style=color:#61676ccc>;
</span><span>        </span><span style=color:#fa6e32>let</span><span> backtrace </span><span style=color:#ed9366>= </span><span>backtrace</span><span style=color:#ed9366>::</span><span>Backtrace</span><span style=color:#ed9366>::</span><span>new()</span><span style=color:#61676ccc>;
</span><span>        
</span><span>        </span><span style=color:#fa6e32>let</span><span> panic_message </span><span style=color:#ed9366>= </span><span style=color:#f07171>format!</span><span>(</span><span style=color:#86b300>"[</span><span style=color:#ff8f40>{}</span><span style=color:#86b300>] Panic: </span><span style=color:#ff8f40>{}</span><span style=color:#4cbf99>\n</span><span style=color:#86b300>Backtrace:</span><span style=color:#4cbf99>\n</span><span style=color:#ff8f40>{:?}</span><span style=color:#4cbf99>\n\n</span><span style=color:#86b300>"</span><span style=color:#61676ccc>, 
</span><span>            timestamp</span><span style=color:#61676ccc>,</span><span> panic_info</span><span style=color:#61676ccc>,</span><span> backtrace)</span><span style=color:#61676ccc>;
</span><span>            
</span><span>        </span><span style=color:#abb0b6;font-style:italic>// Log to file
</span><span>        </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Ok</span><span>(</span><span style=color:#fa6e32>mut</span><span> file) </span><span style=color:#ed9366>= </span><span>OpenOptions</span><span style=color:#ed9366>::</span><span>new()
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>create</span><span>(</span><span style=color:#ff8f40>true</span><span>)
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>append</span><span>(</span><span style=color:#ff8f40>true</span><span>)
</span><span>            </span><span style=color:#ed9366>.</span><span style=color:#f07171>open</span><span>(</span><span style=color:#86b300>"panic.log"</span><span>) 
</span><span>        {
</span><span>            </span><span style=color:#fa6e32>let </span><span style=color:#ed9366>_ =</span><span> file</span><span style=color:#ed9366>.</span><span style=color:#f07171>write_all</span><span>(panic_message</span><span style=color:#ed9366>.</span><span style=color:#f07171>as_bytes</span><span>())</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>        }))</span><span style=color:#61676ccc>;
</span><span>
</span><span>    </span><span style=color:#fa6e32>fn </span><span style=color:#f29718>process_request</span><span>() {
</span><span>       </span><span style=color:#f07171>panic!</span><span>(</span><span style=color:#86b300>"Database connection failed"</span><span>)</span><span style=color:#61676ccc>; </span><span style=color:#abb0b6;font-style:italic>// Example panic
</span><span>    }
</span><span>
</span></code></pre><p>In the above example, we are calling a panic hook to generate a timestamp and backtrace, then format this and write it out to a file. Essentially, we are logging any panics that occur. No matter at what point in the code a panic is triggered, <code>set_hook</code> will be invoked automatically.<p><code>set_hook</code> is more powerful in a way that it supports obtaining references to the type which was passed under <code>panic</code> macro, here is a example for that<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span>panic</span><span style=color:#ed9366>::</span><span>set_hook(</span><span style=color:#55b4d4;font-style:italic>Box</span><span style=color:#ed9366>::</span><span>new(|</span><span style=color:#ff8f40>panic_info</span><span>| {
</span><span>    </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(s) </span><span style=color:#ed9366>=</span><span> panic_info</span><span style=color:#ed9366>.</span><span style=color:#f07171>payload</span><span>()</span><span style=color:#ed9366>.</span><span>downcast_ref</span><span style=color:#ed9366>::</span><span><</span><span style=color:#ed9366>&</span><span style=color:#fa6e32>str</span><span>>() {
</span><span>        </span><span style=color:#f07171>println!</span><span>(</span><span style=color:#86b300>"panic occurred: </span><span style=color:#ff8f40>{s:?}</span><span style=color:#86b300>"</span><span>)</span><span style=color:#61676ccc>;
</span><span>    } </span><span style=color:#fa6e32>else if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(s) </span><span style=color:#ed9366>=</span><span> panic_info</span><span style=color:#ed9366>.</span><span style=color:#f07171>payload</span><span>()</span><span style=color:#ed9366>.</span><span>downcast_ref</span><span style=color:#ed9366>::</span><span><</span><span style=color:#55b4d4;font-style:italic>String</span><span>>() {
</span><span>        </span><span style=color:#f07171>println!</span><span>(</span><span style=color:#86b300>"panic occurred: </span><span style=color:#ff8f40>{s:?}</span><span style=color:#86b300>"</span><span>)</span><span style=color:#61676ccc>;
</span><span>    } </span><span style=color:#fa6e32>else </span><span>{
</span><span>        </span><span style=color:#f07171>println!</span><span>(</span><span style=color:#86b300>"panic occurred"</span><span>)</span><span style=color:#61676ccc>;
</span><span>    }
</span><span>}))</span><span style=color:#61676ccc>;
</span><span>
</span><span style=color:#f07171>panic!</span><span>(</span><span style=color:#86b300>"Normal panic"</span><span>)</span><span style=color:#61676ccc>;
</span></code></pre><p>In the above, we panic with a <code>&str</code> message and later call the <code>payload</code> method over it, which returns <code>&(dyn Any + Send)</code>. We can then apply <code>downcast_ref</code> to obtain a read-only reference for that type. Here is another example with a <code>Vec&LTi32></code>:<pre class=language-rust data-lang=rust style=color:#61676c;background-color:#fafafa><code class=language-rust data-lang=rust><span>std</span><span style=color:#ed9366>::</span><span>panic</span><span style=color:#ed9366>::</span><span>set_hook(</span><span style=color:#55b4d4;font-style:italic>Box</span><span style=color:#ed9366>::</span><span>new(|</span><span style=color:#ff8f40>panic_info</span><span>| {
</span><span>        </span><span style=color:#fa6e32>if let </span><span style=color:#55b4d4;font-style:italic>Some</span><span>(s) </span><span style=color:#ed9366>=</span><span> panic_info</span><span style=color:#ed9366>.</span><span style=color:#f07171>payload</span><span>()</span><span style=color:#ed9366>.</span><span>downcast_ref</span><span style=color:#ed9366>::</span><span><</span><span style=color:#55b4d4;font-style:italic>Vec</span><span><</span><span style=color:#fa6e32>i32</span><span>>>() {
</span><span>            </span><span style=color:#f07171>println!</span><span>(</span><span style=color:#86b300>"panic occurred: </span><span style=color:#ff8f40>{:?}</span><span style=color:#86b300>"</span><span style=color:#61676ccc>,</span><span> s)</span><span style=color:#61676ccc>;
</span><span>        } </span><span style=color:#fa6e32>else </span><span>{
</span><span>            </span><span style=color:#f07171>println!</span><span>(</span><span style=color:#86b300>"panic occurred with unknown payload"</span><span>)</span><span style=color:#61676ccc>;
</span><span>        }
</span><span>    }))</span><span style=color:#61676ccc>;
</span><span>    
</span><span style=color:#fa6e32>let</span><span> val </span><span style=color:#ed9366>= </span><span style=color:#f07171>vec!</span><span>[</span><span style=color:#ff8f40>1</span><span style=color:#61676ccc>,</span><span style=color:#ff8f40>2</span><span style=color:#61676ccc>,</span><span style=color:#ff8f40>3</span><span style=color:#61676ccc>,</span><span style=color:#ff8f40>4</span><span style=color:#61676ccc>,</span><span style=color:#ff8f40>5</span><span>]</span><span style=color:#61676ccc>;
</span><span>    
</span><span>std</span><span style=color:#ed9366>::</span><span>panic</span><span style=color:#ed9366>::</span><span>panic_any(val)</span><span style=color:#61676ccc>;
</span></code></pre><p>If you notice, in the last line we have utilized the <a href=https://doc.rust-lang.org/std/panic/fn.panic_any.html><code>std::panic::panic_any</code></a> method rather than the <code>panic</code> macro. This is because the <code>panic</code> macro only allows string literals to be passed within itself, whereas <code>std::panic::panic_any</code> allows us to use <code>'static + Any + Send</code> as our argument. If you are wondering what the purpose of <code>std::any::Any</code> is, you may check out <a href=https://quinedot.github.io/rust-learning/dyn-any.html>this</a> blog post.<p>I hope you learnt something interesting and useful through this blog post, feel free to share your thoughts with me ;)</section></article></main><div class=giscus></div><script async crossorigin issue-term=pathname repo=not-matthias/apollo src=https://utteranc.es/client.js theme=github-light></script></div>